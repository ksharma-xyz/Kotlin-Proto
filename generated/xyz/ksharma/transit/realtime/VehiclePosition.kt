// Code generated by Wire protocol buffer compiler, do not edit.
// Source: transit_realtime.VehiclePosition in xyz/ksharma/transport/gtfs_realtime.proto
@file:Suppress("DEPRECATION")

package xyz.ksharma.transit.realtime

import com.squareup.wire.EnumAdapter
import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.ReverseProtoWriter
import com.squareup.wire.Syntax.PROTO_2
import com.squareup.wire.WireEnum
import com.squareup.wire.WireField
import com.squareup.wire.`internal`.JvmField
import com.squareup.wire.`internal`.JvmStatic
import com.squareup.wire.`internal`.JvmSynthetic
import com.squareup.wire.`internal`.checkElementsNotNull
import com.squareup.wire.`internal`.immutableCopyOf
import com.squareup.wire.`internal`.redactElements
import com.squareup.wire.`internal`.sanitize
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.Suppress
import kotlin.Unit
import kotlin.collections.List
import okio.ByteString

/**
 * Realtime positioning information for a given vehicle.
 */
public class VehiclePosition(
  /**
   * The Trip that this vehicle is serving.
   * Can be empty or partial if the vehicle can not be identified with a given
   * trip instance.
   */
  @field:WireField(
    tag = 1,
    adapter = "xyz.ksharma.transit.realtime.TripDescriptor#ADAPTER",
    schemaIndex = 0,
  )
  @JvmField
  public val trip: TripDescriptor? = null,
  /**
   * Additional information on the vehicle that is serving this trip.
   */
  @field:WireField(
    tag = 8,
    adapter = "xyz.ksharma.transit.realtime.VehicleDescriptor#ADAPTER",
    schemaIndex = 1,
  )
  @JvmField
  public val vehicle: VehicleDescriptor? = null,
  /**
   * Current position of this vehicle.
   */
  @field:WireField(
    tag = 2,
    adapter = "xyz.ksharma.transit.realtime.Position#ADAPTER",
    schemaIndex = 2,
  )
  @JvmField
  public val position: Position? = null,
  /**
   * The stop sequence index of the current stop. The meaning of
   * current_stop_sequence (i.e., the stop that it refers to) is determined by
   * current_status.
   * If current_status is missing IN_TRANSIT_TO is assumed.
   */
  @field:WireField(
    tag = 3,
    adapter = "com.squareup.wire.ProtoAdapter#UINT32",
    schemaIndex = 3,
  )
  @JvmField
  public val current_stop_sequence: Int? = null,
  /**
   * Identifies the current stop. The value must be the same as in stops.txt in
   * the corresponding GTFS feed.
   */
  @field:WireField(
    tag = 7,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    schemaIndex = 4,
  )
  @JvmField
  public val stop_id: String? = null,
  /**
   * The exact status of the vehicle with respect to the current stop.
   * Ignored if current_stop_sequence is missing.
   */
  @field:WireField(
    tag = 4,
    adapter = "xyz.ksharma.transit.realtime.VehiclePosition${'$'}VehicleStopStatus#ADAPTER",
    schemaIndex = 5,
  )
  @JvmField
  public val current_status: VehicleStopStatus? = null,
  /**
   * Moment at which the vehicle's position was measured. In POSIX time
   * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
   */
  @field:WireField(
    tag = 5,
    adapter = "com.squareup.wire.ProtoAdapter#UINT64",
    schemaIndex = 6,
  )
  @JvmField
  public val timestamp: Long? = null,
  @field:WireField(
    tag = 6,
    adapter = "xyz.ksharma.transit.realtime.VehiclePosition${'$'}CongestionLevel#ADAPTER",
    schemaIndex = 7,
  )
  @JvmField
  public val congestion_level: CongestionLevel? = null,
  /**
   * If multi_carriage_status is populated with per-carriage OccupancyStatus,
   * then this field should describe the entire vehicle with all carriages accepting passengers
   * considered.
   */
  @field:WireField(
    tag = 9,
    adapter = "xyz.ksharma.transit.realtime.VehiclePosition${'$'}OccupancyStatus#ADAPTER",
    schemaIndex = 8,
  )
  @JvmField
  public val occupancy_status: OccupancyStatus? = null,
  /**
   * A percentage value indicating the degree of passenger occupancy in the vehicle.
   * The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
   * The value 100 should represent the total maximum occupancy the vehicle was designed for,
   * including both seated and standing capacity, and current operating regulations allow.
   * The value may exceed 100 if there are more passengers than the maximum designed capacity.
   * The precision of occupancy_percentage should be low enough that individual passengers cannot be
   * tracked boarding or alighting the vehicle.
   * If multi_carriage_status is populated with per-carriage occupancy_percentage,
   * then this field should describe the entire vehicle with all carriages accepting passengers
   * considered.
   * This field is still experimental, and subject to change. It may be formally adopted in the
   * future.
   */
  @field:WireField(
    tag = 10,
    adapter = "com.squareup.wire.ProtoAdapter#UINT32",
    schemaIndex = 9,
  )
  @JvmField
  public val occupancy_percentage: Int? = null,
  multi_carriage_details: List<CarriageDetails> = emptyList(),
  unknownFields: ByteString = ByteString.EMPTY,
) : Message<VehiclePosition, VehiclePosition.Builder>(ADAPTER, unknownFields) {
  /**
   * Details of the multiple carriages of this given vehicle.
   * The first occurrence represents the first carriage of the vehicle,
   * given the current direction of travel.
   * The number of occurrences of the multi_carriage_details
   * field represents the number of carriages of the vehicle.
   * It also includes non boardable carriages,
   * like engines, maintenance carriages, etcâ€¦ as they provide valuable
   * information to passengers about where to stand on a platform.
   * This message/field is still experimental, and subject to change. It may be formally adopted in
   * the future.
   */
  @field:WireField(
    tag = 11,
    adapter = "xyz.ksharma.transit.realtime.VehiclePosition${'$'}CarriageDetails#ADAPTER",
    label = WireField.Label.REPEATED,
    schemaIndex = 10,
  )
  @JvmField
  public val multi_carriage_details: List<CarriageDetails> =
      immutableCopyOf("multi_carriage_details", multi_carriage_details)

  override fun newBuilder(): Builder {
    val builder = Builder()
    builder.trip = trip
    builder.vehicle = vehicle
    builder.position = position
    builder.current_stop_sequence = current_stop_sequence
    builder.stop_id = stop_id
    builder.current_status = current_status
    builder.timestamp = timestamp
    builder.congestion_level = congestion_level
    builder.occupancy_status = occupancy_status
    builder.occupancy_percentage = occupancy_percentage
    builder.multi_carriage_details = multi_carriage_details
    builder.addUnknownFields(unknownFields)
    return builder
  }

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is VehiclePosition) return false
    if (unknownFields != other.unknownFields) return false
    if (trip != other.trip) return false
    if (vehicle != other.vehicle) return false
    if (position != other.position) return false
    if (current_stop_sequence != other.current_stop_sequence) return false
    if (stop_id != other.stop_id) return false
    if (current_status != other.current_status) return false
    if (timestamp != other.timestamp) return false
    if (congestion_level != other.congestion_level) return false
    if (occupancy_status != other.occupancy_status) return false
    if (occupancy_percentage != other.occupancy_percentage) return false
    if (multi_carriage_details != other.multi_carriage_details) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + (trip?.hashCode() ?: 0)
      result = result * 37 + (vehicle?.hashCode() ?: 0)
      result = result * 37 + (position?.hashCode() ?: 0)
      result = result * 37 + (current_stop_sequence?.hashCode() ?: 0)
      result = result * 37 + (stop_id?.hashCode() ?: 0)
      result = result * 37 + (current_status?.hashCode() ?: 0)
      result = result * 37 + (timestamp?.hashCode() ?: 0)
      result = result * 37 + (congestion_level?.hashCode() ?: 0)
      result = result * 37 + (occupancy_status?.hashCode() ?: 0)
      result = result * 37 + (occupancy_percentage?.hashCode() ?: 0)
      result = result * 37 + multi_carriage_details.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    if (trip != null) result += """trip=$trip"""
    if (vehicle != null) result += """vehicle=$vehicle"""
    if (position != null) result += """position=$position"""
    if (current_stop_sequence != null) result += """current_stop_sequence=$current_stop_sequence"""
    if (stop_id != null) result += """stop_id=${sanitize(stop_id)}"""
    if (current_status != null) result += """current_status=$current_status"""
    if (timestamp != null) result += """timestamp=$timestamp"""
    if (congestion_level != null) result += """congestion_level=$congestion_level"""
    if (occupancy_status != null) result += """occupancy_status=$occupancy_status"""
    if (occupancy_percentage != null) result += """occupancy_percentage=$occupancy_percentage"""
    if (multi_carriage_details.isNotEmpty()) result +=
        """multi_carriage_details=$multi_carriage_details"""
    return result.joinToString(prefix = "VehiclePosition{", separator = ", ", postfix = "}")
  }

  public fun copy(
    trip: TripDescriptor? = this.trip,
    vehicle: VehicleDescriptor? = this.vehicle,
    position: Position? = this.position,
    current_stop_sequence: Int? = this.current_stop_sequence,
    stop_id: String? = this.stop_id,
    current_status: VehicleStopStatus? = this.current_status,
    timestamp: Long? = this.timestamp,
    congestion_level: CongestionLevel? = this.congestion_level,
    occupancy_status: OccupancyStatus? = this.occupancy_status,
    occupancy_percentage: Int? = this.occupancy_percentage,
    multi_carriage_details: List<CarriageDetails> = this.multi_carriage_details,
    unknownFields: ByteString = this.unknownFields,
  ): VehiclePosition = VehiclePosition(trip, vehicle, position, current_stop_sequence, stop_id,
      current_status, timestamp, congestion_level, occupancy_status, occupancy_percentage,
      multi_carriage_details, unknownFields)

  public class Builder : Message.Builder<VehiclePosition, Builder>() {
    @JvmField
    public var trip: TripDescriptor? = null

    @JvmField
    public var vehicle: VehicleDescriptor? = null

    @JvmField
    public var position: Position? = null

    @JvmField
    public var current_stop_sequence: Int? = null

    @JvmField
    public var stop_id: String? = null

    @JvmField
    public var current_status: VehicleStopStatus? = null

    @JvmField
    public var timestamp: Long? = null

    @JvmField
    public var congestion_level: CongestionLevel? = null

    @JvmField
    public var occupancy_status: OccupancyStatus? = null

    @JvmField
    public var occupancy_percentage: Int? = null

    @JvmField
    public var multi_carriage_details: List<CarriageDetails> = emptyList()

    /**
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     */
    public fun trip(trip: TripDescriptor?): Builder {
      this.trip = trip
      return this
    }

    /**
     * Additional information on the vehicle that is serving this trip.
     */
    public fun vehicle(vehicle: VehicleDescriptor?): Builder {
      this.vehicle = vehicle
      return this
    }

    /**
     * Current position of this vehicle.
     */
    public fun position(position: Position?): Builder {
      this.position = position
      return this
    }

    /**
     * The stop sequence index of the current stop. The meaning of
     * current_stop_sequence (i.e., the stop that it refers to) is determined by
     * current_status.
     * If current_status is missing IN_TRANSIT_TO is assumed.
     */
    public fun current_stop_sequence(current_stop_sequence: Int?): Builder {
      this.current_stop_sequence = current_stop_sequence
      return this
    }

    /**
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     */
    public fun stop_id(stop_id: String?): Builder {
      this.stop_id = stop_id
      return this
    }

    /**
     * The exact status of the vehicle with respect to the current stop.
     * Ignored if current_stop_sequence is missing.
     */
    public fun current_status(current_status: VehicleStopStatus?): Builder {
      this.current_status = current_status
      return this
    }

    /**
     * Moment at which the vehicle's position was measured. In POSIX time
     * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     */
    public fun timestamp(timestamp: Long?): Builder {
      this.timestamp = timestamp
      return this
    }

    public fun congestion_level(congestion_level: CongestionLevel?): Builder {
      this.congestion_level = congestion_level
      return this
    }

    /**
     * If multi_carriage_status is populated with per-carriage OccupancyStatus,
     * then this field should describe the entire vehicle with all carriages accepting passengers
     * considered.
     */
    public fun occupancy_status(occupancy_status: OccupancyStatus?): Builder {
      this.occupancy_status = occupancy_status
      return this
    }

    /**
     * A percentage value indicating the degree of passenger occupancy in the vehicle.
     * The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
     * The value 100 should represent the total maximum occupancy the vehicle was designed for,
     * including both seated and standing capacity, and current operating regulations allow.
     * The value may exceed 100 if there are more passengers than the maximum designed capacity.
     * The precision of occupancy_percentage should be low enough that individual passengers cannot
     * be tracked boarding or alighting the vehicle.
     * If multi_carriage_status is populated with per-carriage occupancy_percentage,
     * then this field should describe the entire vehicle with all carriages accepting passengers
     * considered.
     * This field is still experimental, and subject to change. It may be formally adopted in the
     * future.
     */
    public fun occupancy_percentage(occupancy_percentage: Int?): Builder {
      this.occupancy_percentage = occupancy_percentage
      return this
    }

    /**
     * Details of the multiple carriages of this given vehicle.
     * The first occurrence represents the first carriage of the vehicle,
     * given the current direction of travel.
     * The number of occurrences of the multi_carriage_details
     * field represents the number of carriages of the vehicle.
     * It also includes non boardable carriages,
     * like engines, maintenance carriages, etcâ€¦ as they provide valuable
     * information to passengers about where to stand on a platform.
     * This message/field is still experimental, and subject to change. It may be formally adopted
     * in the future.
     */
    public fun multi_carriage_details(multi_carriage_details: List<CarriageDetails>): Builder {
      checkElementsNotNull(multi_carriage_details)
      this.multi_carriage_details = multi_carriage_details
      return this
    }

    override fun build(): VehiclePosition = VehiclePosition(
      trip = trip,
      vehicle = vehicle,
      position = position,
      current_stop_sequence = current_stop_sequence,
      stop_id = stop_id,
      current_status = current_status,
      timestamp = timestamp,
      congestion_level = congestion_level,
      occupancy_status = occupancy_status,
      occupancy_percentage = occupancy_percentage,
      multi_carriage_details = multi_carriage_details,
      unknownFields = buildUnknownFields()
    )
  }

  public companion object {
    @JvmField
    public val DEFAULT_CURRENT_STATUS: VehicleStopStatus = VehicleStopStatus.IN_TRANSIT_TO

    @JvmField
    public val ADAPTER: ProtoAdapter<VehiclePosition> = object : ProtoAdapter<VehiclePosition>(
      FieldEncoding.LENGTH_DELIMITED, 
      VehiclePosition::class, 
      "type.googleapis.com/transit_realtime.VehiclePosition", 
      PROTO_2, 
      null, 
      "xyz/ksharma/transport/gtfs_realtime.proto"
    ) {
      override fun encodedSize(`value`: VehiclePosition): Int {
        var size = value.unknownFields.size
        size += TripDescriptor.ADAPTER.encodedSizeWithTag(1, value.trip)
        size += VehicleDescriptor.ADAPTER.encodedSizeWithTag(8, value.vehicle)
        size += Position.ADAPTER.encodedSizeWithTag(2, value.position)
        size += ProtoAdapter.UINT32.encodedSizeWithTag(3, value.current_stop_sequence)
        size += ProtoAdapter.STRING.encodedSizeWithTag(7, value.stop_id)
        size += VehicleStopStatus.ADAPTER.encodedSizeWithTag(4, value.current_status)
        size += ProtoAdapter.UINT64.encodedSizeWithTag(5, value.timestamp)
        size += CongestionLevel.ADAPTER.encodedSizeWithTag(6, value.congestion_level)
        size += OccupancyStatus.ADAPTER.encodedSizeWithTag(9, value.occupancy_status)
        size += ProtoAdapter.UINT32.encodedSizeWithTag(10, value.occupancy_percentage)
        size += CarriageDetails.ADAPTER.asRepeated().encodedSizeWithTag(11,
            value.multi_carriage_details)
        return size
      }

      override fun encode(writer: ProtoWriter, `value`: VehiclePosition) {
        TripDescriptor.ADAPTER.encodeWithTag(writer, 1, value.trip)
        VehicleDescriptor.ADAPTER.encodeWithTag(writer, 8, value.vehicle)
        Position.ADAPTER.encodeWithTag(writer, 2, value.position)
        ProtoAdapter.UINT32.encodeWithTag(writer, 3, value.current_stop_sequence)
        ProtoAdapter.STRING.encodeWithTag(writer, 7, value.stop_id)
        VehicleStopStatus.ADAPTER.encodeWithTag(writer, 4, value.current_status)
        ProtoAdapter.UINT64.encodeWithTag(writer, 5, value.timestamp)
        CongestionLevel.ADAPTER.encodeWithTag(writer, 6, value.congestion_level)
        OccupancyStatus.ADAPTER.encodeWithTag(writer, 9, value.occupancy_status)
        ProtoAdapter.UINT32.encodeWithTag(writer, 10, value.occupancy_percentage)
        CarriageDetails.ADAPTER.asRepeated().encodeWithTag(writer, 11, value.multi_carriage_details)
        writer.writeBytes(value.unknownFields)
      }

      override fun encode(writer: ReverseProtoWriter, `value`: VehiclePosition) {
        writer.writeBytes(value.unknownFields)
        CarriageDetails.ADAPTER.asRepeated().encodeWithTag(writer, 11, value.multi_carriage_details)
        ProtoAdapter.UINT32.encodeWithTag(writer, 10, value.occupancy_percentage)
        OccupancyStatus.ADAPTER.encodeWithTag(writer, 9, value.occupancy_status)
        CongestionLevel.ADAPTER.encodeWithTag(writer, 6, value.congestion_level)
        ProtoAdapter.UINT64.encodeWithTag(writer, 5, value.timestamp)
        VehicleStopStatus.ADAPTER.encodeWithTag(writer, 4, value.current_status)
        ProtoAdapter.STRING.encodeWithTag(writer, 7, value.stop_id)
        ProtoAdapter.UINT32.encodeWithTag(writer, 3, value.current_stop_sequence)
        Position.ADAPTER.encodeWithTag(writer, 2, value.position)
        VehicleDescriptor.ADAPTER.encodeWithTag(writer, 8, value.vehicle)
        TripDescriptor.ADAPTER.encodeWithTag(writer, 1, value.trip)
      }

      override fun decode(reader: ProtoReader): VehiclePosition {
        var trip: TripDescriptor? = null
        var vehicle: VehicleDescriptor? = null
        var position: Position? = null
        var current_stop_sequence: Int? = null
        var stop_id: String? = null
        var current_status: VehicleStopStatus? = null
        var timestamp: Long? = null
        var congestion_level: CongestionLevel? = null
        var occupancy_status: OccupancyStatus? = null
        var occupancy_percentage: Int? = null
        val multi_carriage_details = mutableListOf<CarriageDetails>()
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> trip = TripDescriptor.ADAPTER.decode(reader)
            8 -> vehicle = VehicleDescriptor.ADAPTER.decode(reader)
            2 -> position = Position.ADAPTER.decode(reader)
            3 -> current_stop_sequence = ProtoAdapter.UINT32.decode(reader)
            7 -> stop_id = ProtoAdapter.STRING.decode(reader)
            4 -> try {
              current_status = VehicleStopStatus.ADAPTER.decode(reader)
            } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
              reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
            }
            5 -> timestamp = ProtoAdapter.UINT64.decode(reader)
            6 -> try {
              congestion_level = CongestionLevel.ADAPTER.decode(reader)
            } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
              reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
            }
            9 -> try {
              occupancy_status = OccupancyStatus.ADAPTER.decode(reader)
            } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
              reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
            }
            10 -> occupancy_percentage = ProtoAdapter.UINT32.decode(reader)
            11 -> multi_carriage_details.add(CarriageDetails.ADAPTER.decode(reader))
            else -> reader.readUnknownField(tag)
          }
        }
        return VehiclePosition(
          trip = trip,
          vehicle = vehicle,
          position = position,
          current_stop_sequence = current_stop_sequence,
          stop_id = stop_id,
          current_status = current_status,
          timestamp = timestamp,
          congestion_level = congestion_level,
          occupancy_status = occupancy_status,
          occupancy_percentage = occupancy_percentage,
          multi_carriage_details = multi_carriage_details,
          unknownFields = unknownFields
        )
      }

      override fun redact(`value`: VehiclePosition): VehiclePosition = value.copy(
        trip = value.trip?.let(TripDescriptor.ADAPTER::redact),
        vehicle = value.vehicle?.let(VehicleDescriptor.ADAPTER::redact),
        position = value.position?.let(Position.ADAPTER::redact),
        multi_carriage_details =
            value.multi_carriage_details.redactElements(CarriageDetails.ADAPTER),
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L

    @JvmSynthetic
    public inline fun build(body: Builder.() -> Unit): VehiclePosition =
        Builder().apply(body).build()
  }

  public enum class VehicleStopStatus(
    override val `value`: Int,
  ) : WireEnum {
    /**
     * The vehicle is just about to arrive at the stop (on a stop
     * display, the vehicle symbol typically flashes).
     */
    INCOMING_AT(0),
    /**
     * The vehicle is standing at the stop.
     */
    STOPPED_AT(1),
    /**
     * The vehicle has departed and is in transit to the next stop.
     */
    IN_TRANSIT_TO(2),
    ;

    public companion object {
      @JvmField
      public val ADAPTER: ProtoAdapter<VehicleStopStatus> = object : EnumAdapter<VehicleStopStatus>(
        VehicleStopStatus::class, 
        PROTO_2, 
        VehicleStopStatus.INCOMING_AT
      ) {
        override fun fromValue(`value`: Int): VehicleStopStatus? =
            VehicleStopStatus.fromValue(`value`)
      }

      @JvmStatic
      public fun fromValue(`value`: Int): VehicleStopStatus? = when (`value`) {
        0 -> INCOMING_AT
        1 -> STOPPED_AT
        2 -> IN_TRANSIT_TO
        else -> null
      }
    }
  }

  /**
   * Congestion level that is affecting this vehicle.
   */
  public enum class CongestionLevel(
    override val `value`: Int,
  ) : WireEnum {
    UNKNOWN_CONGESTION_LEVEL(0),
    RUNNING_SMOOTHLY(1),
    STOP_AND_GO(2),
    CONGESTION(3),
    /**
     * People leaving their cars.
     */
    SEVERE_CONGESTION(4),
    ;

    public companion object {
      @JvmField
      public val ADAPTER: ProtoAdapter<CongestionLevel> = object : EnumAdapter<CongestionLevel>(
        CongestionLevel::class, 
        PROTO_2, 
        CongestionLevel.UNKNOWN_CONGESTION_LEVEL
      ) {
        override fun fromValue(`value`: Int): CongestionLevel? = CongestionLevel.fromValue(`value`)
      }

      @JvmStatic
      public fun fromValue(`value`: Int): CongestionLevel? = when (`value`) {
        0 -> UNKNOWN_CONGESTION_LEVEL
        1 -> RUNNING_SMOOTHLY
        2 -> STOP_AND_GO
        3 -> CONGESTION
        4 -> SEVERE_CONGESTION
        else -> null
      }
    }
  }

  /**
   * The state of passenger occupancy for the vehicle or carriage.
   * Individual producers may not publish all OccupancyStatus values. Therefore, consumers
   * must not assume that the OccupancyStatus values follow a linear scale.
   * Consumers should represent OccupancyStatus values as the state indicated
   * and intended by the producer. Likewise, producers must use OccupancyStatus values that
   * correspond to actual vehicle occupancy states.
   * For describing passenger occupancy levels on a linear scale, see `occupancy_percentage`.
   * This field is still experimental, and subject to change. It may be formally adopted in the
   * future.
   */
  public enum class OccupancyStatus(
    override val `value`: Int,
  ) : WireEnum {
    /**
     * The vehicle or carriage is considered empty by most measures, and has few or no
     * passengers onboard, but is still accepting passengers.
     */
    EMPTY(0),
    /**
     * The vehicle or carriage has a large number of seats available.
     * The amount of free seats out of the total seats available to be
     * considered large enough to fall into this category is determined at the
     * discretion of the producer.
     */
    MANY_SEATS_AVAILABLE(1),
    /**
     * The vehicle or carriage has a relatively small number of seats available.
     * The amount of free seats out of the total seats available to be
     * considered small enough to fall into this category is determined at the
     * discretion of the feed producer.
     */
    FEW_SEATS_AVAILABLE(2),
    /**
     * The vehicle or carriage can currently accommodate only standing passengers.
     */
    STANDING_ROOM_ONLY(3),
    /**
     * The vehicle or carriage can currently accommodate only standing passengers
     * and has limited space for them.
     */
    CRUSHED_STANDING_ROOM_ONLY(4),
    /**
     * The vehicle or carriage is considered full by most measures, but may still be
     * allowing passengers to board.
     */
    FULL(5),
    /**
     * The vehicle or carriage is not accepting passengers, but usually accepts passengers for
     * boarding.
     */
    NOT_ACCEPTING_PASSENGERS(6),
    /**
     * The vehicle or carriage doesn't have any occupancy data available at that time.
     */
    NO_DATA_AVAILABLE(7),
    /**
     * The vehicle or carriage is not boardable and never accepts passengers.
     * Useful for special vehicles or carriages (engine, maintenance carriage, etcâ€¦).
     */
    NOT_BOARDABLE(8),
    ;

    public companion object {
      @JvmField
      public val ADAPTER: ProtoAdapter<OccupancyStatus> = object : EnumAdapter<OccupancyStatus>(
        OccupancyStatus::class, 
        PROTO_2, 
        OccupancyStatus.EMPTY
      ) {
        override fun fromValue(`value`: Int): OccupancyStatus? = OccupancyStatus.fromValue(`value`)
      }

      @JvmStatic
      public fun fromValue(`value`: Int): OccupancyStatus? = when (`value`) {
        0 -> EMPTY
        1 -> MANY_SEATS_AVAILABLE
        2 -> FEW_SEATS_AVAILABLE
        3 -> STANDING_ROOM_ONLY
        4 -> CRUSHED_STANDING_ROOM_ONLY
        5 -> FULL
        6 -> NOT_ACCEPTING_PASSENGERS
        7 -> NO_DATA_AVAILABLE
        8 -> NOT_BOARDABLE
        else -> null
      }
    }
  }

  /**
   * Carriage specific details, used for vehicles composed of several carriages
   * This message/field is still experimental, and subject to change. It may be formally adopted in
   * the future.
   */
  public class CarriageDetails(
    /**
     * Identification of the carriage. Should be unique per vehicle.
     */
    @field:WireField(
      tag = 1,
      adapter = "com.squareup.wire.ProtoAdapter#STRING",
      schemaIndex = 0,
    )
    @JvmField
    public val id: String? = null,
    /**
     * User visible label that may be shown to the passenger to help identify
     * the carriage. Example: "7712", "Car ABC-32", etc...
     * This message/field is still experimental, and subject to change. It may be formally adopted
     * in the future.
     */
    @field:WireField(
      tag = 2,
      adapter = "com.squareup.wire.ProtoAdapter#STRING",
      schemaIndex = 1,
    )
    @JvmField
    public val label: String? = null,
    /**
     * Occupancy status for this given carriage, in this vehicle
     * This message/field is still experimental, and subject to change. It may be formally adopted
     * in the future.
     */
    @field:WireField(
      tag = 3,
      adapter = "xyz.ksharma.transit.realtime.VehiclePosition${'$'}OccupancyStatus#ADAPTER",
      schemaIndex = 2,
    )
    @JvmField
    public val occupancy_status: OccupancyStatus? = null,
    /**
     * Occupancy percentage for this given carriage, in this vehicle.
     * Follows the same rules as "VehiclePosition.occupancy_percentage"
     * -1 in case data is not available for this given carriage (as protobuf defaults to 0
     * otherwise)
     * This message/field is still experimental, and subject to change. It may be formally adopted
     * in the future.
     */
    @field:WireField(
      tag = 4,
      adapter = "com.squareup.wire.ProtoAdapter#INT32",
      schemaIndex = 3,
    )
    @JvmField
    public val occupancy_percentage: Int? = null,
    /**
     * Identifies the order of this carriage with respect to the other
     * carriages in the vehicle's list of CarriageDetails.
     * The first carriage in the direction of travel must have a value of 1.
     * The second value corresponds to the second carriage in the direction
     * of travel and must have a value of 2, and so forth.
     * For example, the first carriage in the direction of travel has a value of 1.
     * If the second carriage in the direction of travel has a value of 3,
     * consumers will discard data for all carriages (i.e., the multi_carriage_details field).
     * Carriages without data must be represented with a valid carriage_sequence number and the
     * fields
     * without data should be omitted (alternately, those fields could also be included and set to
     * the "no data" values).
     * This message/field is still experimental, and subject to change. It may be formally adopted
     * in the future.
     */
    @field:WireField(
      tag = 5,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32",
      schemaIndex = 4,
    )
    @JvmField
    public val carriage_sequence: Int? = null,
    unknownFields: ByteString = ByteString.EMPTY,
  ) : Message<CarriageDetails, CarriageDetails.Builder>(ADAPTER, unknownFields) {
    override fun newBuilder(): Builder {
      val builder = Builder()
      builder.id = id
      builder.label = label
      builder.occupancy_status = occupancy_status
      builder.occupancy_percentage = occupancy_percentage
      builder.carriage_sequence = carriage_sequence
      builder.addUnknownFields(unknownFields)
      return builder
    }

    override fun equals(other: Any?): Boolean {
      if (other === this) return true
      if (other !is CarriageDetails) return false
      if (unknownFields != other.unknownFields) return false
      if (id != other.id) return false
      if (label != other.label) return false
      if (occupancy_status != other.occupancy_status) return false
      if (occupancy_percentage != other.occupancy_percentage) return false
      if (carriage_sequence != other.carriage_sequence) return false
      return true
    }

    override fun hashCode(): Int {
      var result = super.hashCode
      if (result == 0) {
        result = unknownFields.hashCode()
        result = result * 37 + (id?.hashCode() ?: 0)
        result = result * 37 + (label?.hashCode() ?: 0)
        result = result * 37 + (occupancy_status?.hashCode() ?: 0)
        result = result * 37 + (occupancy_percentage?.hashCode() ?: 0)
        result = result * 37 + (carriage_sequence?.hashCode() ?: 0)
        super.hashCode = result
      }
      return result
    }

    override fun toString(): String {
      val result = mutableListOf<String>()
      if (id != null) result += """id=${sanitize(id)}"""
      if (label != null) result += """label=${sanitize(label)}"""
      if (occupancy_status != null) result += """occupancy_status=$occupancy_status"""
      if (occupancy_percentage != null) result += """occupancy_percentage=$occupancy_percentage"""
      if (carriage_sequence != null) result += """carriage_sequence=$carriage_sequence"""
      return result.joinToString(prefix = "CarriageDetails{", separator = ", ", postfix = "}")
    }

    public fun copy(
      id: String? = this.id,
      label: String? = this.label,
      occupancy_status: OccupancyStatus? = this.occupancy_status,
      occupancy_percentage: Int? = this.occupancy_percentage,
      carriage_sequence: Int? = this.carriage_sequence,
      unknownFields: ByteString = this.unknownFields,
    ): CarriageDetails = CarriageDetails(id, label, occupancy_status, occupancy_percentage,
        carriage_sequence, unknownFields)

    public class Builder : Message.Builder<CarriageDetails, Builder>() {
      @JvmField
      public var id: String? = null

      @JvmField
      public var label: String? = null

      @JvmField
      public var occupancy_status: OccupancyStatus? = null

      @JvmField
      public var occupancy_percentage: Int? = null

      @JvmField
      public var carriage_sequence: Int? = null

      /**
       * Identification of the carriage. Should be unique per vehicle.
       */
      public fun id(id: String?): Builder {
        this.id = id
        return this
      }

      /**
       * User visible label that may be shown to the passenger to help identify
       * the carriage. Example: "7712", "Car ABC-32", etc...
       * This message/field is still experimental, and subject to change. It may be formally adopted
       * in the future.
       */
      public fun label(label: String?): Builder {
        this.label = label
        return this
      }

      /**
       * Occupancy status for this given carriage, in this vehicle
       * This message/field is still experimental, and subject to change. It may be formally adopted
       * in the future.
       */
      public fun occupancy_status(occupancy_status: OccupancyStatus?): Builder {
        this.occupancy_status = occupancy_status
        return this
      }

      /**
       * Occupancy percentage for this given carriage, in this vehicle.
       * Follows the same rules as "VehiclePosition.occupancy_percentage"
       * -1 in case data is not available for this given carriage (as protobuf defaults to 0
       * otherwise)
       * This message/field is still experimental, and subject to change. It may be formally adopted
       * in the future.
       */
      public fun occupancy_percentage(occupancy_percentage: Int?): Builder {
        this.occupancy_percentage = occupancy_percentage
        return this
      }

      /**
       * Identifies the order of this carriage with respect to the other
       * carriages in the vehicle's list of CarriageDetails.
       * The first carriage in the direction of travel must have a value of 1.
       * The second value corresponds to the second carriage in the direction
       * of travel and must have a value of 2, and so forth.
       * For example, the first carriage in the direction of travel has a value of 1.
       * If the second carriage in the direction of travel has a value of 3,
       * consumers will discard data for all carriages (i.e., the multi_carriage_details field).
       * Carriages without data must be represented with a valid carriage_sequence number and the
       * fields
       * without data should be omitted (alternately, those fields could also be included and set to
       * the "no data" values).
       * This message/field is still experimental, and subject to change. It may be formally adopted
       * in the future.
       */
      public fun carriage_sequence(carriage_sequence: Int?): Builder {
        this.carriage_sequence = carriage_sequence
        return this
      }

      override fun build(): CarriageDetails = CarriageDetails(
        id = id,
        label = label,
        occupancy_status = occupancy_status,
        occupancy_percentage = occupancy_percentage,
        carriage_sequence = carriage_sequence,
        unknownFields = buildUnknownFields()
      )
    }

    public companion object {
      @JvmField
      public val DEFAULT_OCCUPANCY_STATUS: OccupancyStatus = OccupancyStatus.NO_DATA_AVAILABLE

      public const val DEFAULT_OCCUPANCY_PERCENTAGE: Int = -1

      @JvmField
      public val ADAPTER: ProtoAdapter<CarriageDetails> = object : ProtoAdapter<CarriageDetails>(
        FieldEncoding.LENGTH_DELIMITED, 
        CarriageDetails::class, 
        "type.googleapis.com/transit_realtime.VehiclePosition.CarriageDetails", 
        PROTO_2, 
        null, 
        "xyz/ksharma/transport/gtfs_realtime.proto"
      ) {
        override fun encodedSize(`value`: CarriageDetails): Int {
          var size = value.unknownFields.size
          size += ProtoAdapter.STRING.encodedSizeWithTag(1, value.id)
          size += ProtoAdapter.STRING.encodedSizeWithTag(2, value.label)
          size += OccupancyStatus.ADAPTER.encodedSizeWithTag(3, value.occupancy_status)
          size += ProtoAdapter.INT32.encodedSizeWithTag(4, value.occupancy_percentage)
          size += ProtoAdapter.UINT32.encodedSizeWithTag(5, value.carriage_sequence)
          return size
        }

        override fun encode(writer: ProtoWriter, `value`: CarriageDetails) {
          ProtoAdapter.STRING.encodeWithTag(writer, 1, value.id)
          ProtoAdapter.STRING.encodeWithTag(writer, 2, value.label)
          OccupancyStatus.ADAPTER.encodeWithTag(writer, 3, value.occupancy_status)
          ProtoAdapter.INT32.encodeWithTag(writer, 4, value.occupancy_percentage)
          ProtoAdapter.UINT32.encodeWithTag(writer, 5, value.carriage_sequence)
          writer.writeBytes(value.unknownFields)
        }

        override fun encode(writer: ReverseProtoWriter, `value`: CarriageDetails) {
          writer.writeBytes(value.unknownFields)
          ProtoAdapter.UINT32.encodeWithTag(writer, 5, value.carriage_sequence)
          ProtoAdapter.INT32.encodeWithTag(writer, 4, value.occupancy_percentage)
          OccupancyStatus.ADAPTER.encodeWithTag(writer, 3, value.occupancy_status)
          ProtoAdapter.STRING.encodeWithTag(writer, 2, value.label)
          ProtoAdapter.STRING.encodeWithTag(writer, 1, value.id)
        }

        override fun decode(reader: ProtoReader): CarriageDetails {
          var id: String? = null
          var label: String? = null
          var occupancy_status: OccupancyStatus? = null
          var occupancy_percentage: Int? = null
          var carriage_sequence: Int? = null
          val unknownFields = reader.forEachTag { tag ->
            when (tag) {
              1 -> id = ProtoAdapter.STRING.decode(reader)
              2 -> label = ProtoAdapter.STRING.decode(reader)
              3 -> try {
                occupancy_status = OccupancyStatus.ADAPTER.decode(reader)
              } catch (e: ProtoAdapter.EnumConstantNotFoundException) {
                reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())
              }
              4 -> occupancy_percentage = ProtoAdapter.INT32.decode(reader)
              5 -> carriage_sequence = ProtoAdapter.UINT32.decode(reader)
              else -> reader.readUnknownField(tag)
            }
          }
          return CarriageDetails(
            id = id,
            label = label,
            occupancy_status = occupancy_status,
            occupancy_percentage = occupancy_percentage,
            carriage_sequence = carriage_sequence,
            unknownFields = unknownFields
          )
        }

        override fun redact(`value`: CarriageDetails): CarriageDetails = value.copy(
          unknownFields = ByteString.EMPTY
        )
      }

      private const val serialVersionUID: Long = 0L

      @JvmSynthetic
      public inline fun build(body: Builder.() -> Unit): CarriageDetails =
          Builder().apply(body).build()
    }
  }
}
